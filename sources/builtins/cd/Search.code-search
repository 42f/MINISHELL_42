# Query: strlen
# Flags: RegExp
# Including: sources/**
# Excluding: libft/**
# ContextLines: 1

25 results - 15 files

REPO • sources/builtins/builtins_echo_bonus.c:
   8  	{
   9: 		av_len = ft_strlen(*av);
  10  		if (av_len > 0)

  25  	if (av_to_test[0] != '-' || option[0] != '-'
  26: 						|| ft_strlen(av_to_test) < 2 || ft_strlen(option) != 2)
  27  		return (FALSE);

REPO • sources/builtins/builtins_export_bonus.c:
  7  	if (ft_strchr(id_to_test, '+') != NOT_FOUND
  8: 			&& ft_strnstr(id_to_test, "+=", ft_strlen(id_to_test)) == NOT_FOUND)
  9  		return (false);

REPO • sources/builtins/builtins_pwd_bonus.c:
  17  {
  18: 	if (ac != 1 && ft_strlen(av) >= 1 && av[0] == '-')
  19  	{

REPO • sources/builtins/cd/builtins_cd_bonus.c:
    9  	{
   10: 		if (dir == NULL || (ft_strlen(dir) != 0 && dir[0] == '/'))
   11  		{

   25  	}
   26: 	else if (dir && ft_strlen(dir) != 0 && dir[0] != '.' && dir[0] != '/')
   27  		ft_dprintf(2, "%s %s: %s\n", CD_BUILT, dir, strerror(errno));
   28  	free(pwd);
   29: 	return ((errno != 0 && dir != NULL && ft_strlen(dir) != 0
   30  			&& dir[0] != '.' && dir[0] != '/') ? 3 : SUCCESS);

  104  		return (CD_FAIL);
  105: 	if (ac != 1 && ft_strlen(av[1]) != 0
  106  			&& ft_strequ(av[1], STR_MINUS) == FALSE)

  110  	}
  111: 	if (ac != 1 && ft_strlen(av[1]) == 0)
  112  		return (SUCCESS);

  115  	ret = process_cd(av[1]);
  116: 	if (ret == 2 && (ac > 1 && ft_strlen(av[1]) != 0 && av[1][0] != '/'))
  117  	{

REPO • sources/builtins/cd/builtins_cd_check_bonus.c:
  44  	count_dot = 2;
  45: 	if (ft_strlen(directory) > 2 && directory[0] == DOT && directory[1] == DOT)
  46  	{

  65  
  66: 	if (ft_strlen(directory) > 1 && directory[0] == C_MINUS)
  67  	{

REPO • sources/cleaner/cleaner_command/get_envp_av_bonus.c:
  17  	{
  18: 		if (cmd->av[i] != NULL && ft_strlen(cmd->av[i]) != 0)
  19  		{

  36  	{
  37: 		if (cmd->av[i] != NULL && ft_strlen(cmd->av[i]) != 0)
  38  			clean_cmd->count_assign++;

REPO • sources/cleaner/cleaner_command/get_envp_av_utils_bonus.c:
  12  	{
  13: 		if (av[i] != NULL && ft_strlen(av[i]) != 0)
  14  			new_ac++;

  28  	{
  29: 		if (cmd->av[i] != NULL && ft_strlen(cmd->av[i]) != 0)
  30  		{

REPO • sources/cleaner/cleaner_command/get_type_command_bonus.c:
  182  		}
  183: 		if (ft_strlen(cmd->av[i]) == 0 && i + 1 != (size_t)cmd->ac)
  184  		{

REPO • sources/env/get_env_bonus.c:
  13  		cursor = env_lst;
  14: 		target_name_len = ft_strlen(target_env_name);
  15  		while (cursor != NULL && cursor->content != NULL)

REPO • sources/env/get_envp_bonus.c:
  27  
  28: 	env_name_len = ft_strlen(env_name);
  29  	env_value_len = vct_getlen(env_value);

REPO • sources/env/init_env_bonus.c:
  40  
  41: 	if (ft_strnstr(environ, "+=", ft_strlen(environ)) != NOT_FOUND)
  42  		return (true);

REPO • sources/env/parse_env_bonus.c:
  42  		sign_offset = (*overwrite == FALSE) ? 1 : 0;
  43: 		value_len = ft_strlen(env) - name_len - 1 - sign_offset;
  44  		if (value_len >= 0)

REPO • sources/env/print_export_output_utils_bonus.c:
   9  	env_name_2 = ((t_env*)env_2)->env_name;
  10: 	return (ft_strncmp(env_name_1, env_name_2, ft_strlen(env_name_1) + 1));
  11  }

REPO • sources/error_manager/print_errno.c:
  18  		exit_routine(EXIT_MALLOC);
  19: 	if (error_source != NULL && ft_strlen(error_source) >= 2)
  20  	{

REPO • sources/line_editor/init/init_line_editor_bonus.c:
  53  	get_struct(le);
  54: 	le->prompt_len = ft_strlen(PROMPT_LINE_EDITION);
  55  	le->clipboard = vct_new();
