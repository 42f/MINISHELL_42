# Query: vct_
# Flags: CaseSensitive
# Including: sources/**
# Excluding: libft/

598 results - 52 files

REPO • sources/general_utils_bonus.c:
   3: int		safe_vct_cpy(t_vector *dest, t_vector *src)
   9: 	ret = vct_cpy(dest, src);
  15: int		safe_vct_add(t_vector *vct, char c)
  19: 	ret = vct_add(vct, c);
  25: int		safe_vct_addstr(t_vector *vct, char *str)
  29: 	ret = vct_addstr(vct, str);
  35: int		safe_vct_addcharat(t_vector *vct, size_t index, char c)
  39: 	if (vct == NULL || index > vct_getlen(vct) || c == '\0')
  41: 	ret = vct_addcharat(vct, index, c);

REPO • sources/main_bonus.c:
   15: 	if ((read_ret = vct_readline(data->cmd_line, 0)) == FAILURE)
  107: 	cmd_line = vct_new();
  128: 			vct_clear(cmd_line);

REPO • sources/main.c:
  11: 	vct_readline(cmd_line, 0);
  54: 	cmd_line = vct_new();
  68: 				vct_clear(cmd_line);
  74: 		vct_clear(cmd_line);

REPO • sources/test_lexer_bonus.c:
  8: //	ft_printf("\n%s\n", vct_getstr(input));

REPO • sources/builtins/builtins_history_bonus.c:
  16: 									vct_getstr((t_vector *)cursor->content));

REPO • sources/builtins/builtins_pwd_bonus.c:
   7: 	option = vct_new();
   8: 	vct_add(option, str[0]);
   9: 	vct_add(option, str[1]);
  10: 	print_set_errno(0, ERR_PWD_OPT, STR_PWD, vct_getstr(option));
  12: 	vct_del(&option);

REPO • sources/builtins/builtins_unset_bonus.c:
   7:     while (vct != NULL && vct_getlen(vct) > 0)
   9:         c_first = vct_getfirstchar(vct);
  14:             vct_del(&vct);
  17:         vct_pop(vct);
  19:     vct_del(&vct);
  29:     vct = vct_new();
  32:     if (vct_addstr(vct, av_to_check) == FAILURE)
  34:     c_first = vct_getfirstchar(vct);
  35:     c_last = vct_getcharat(vct, vct_getlen(vct) - 1);
  39:         vct_del(&vct);

REPO • sources/builtins/cd/builtins_cd_bonus.c:
  33: static int	process_chdir(t_vector *vct_home, char *dir, char *old_dir,
  39: 	real_dir = !dir && vct_getlen(vct_home) ? vct_getstr(vct_home) : dir;
  59: static int	hub_process_chdir(char *dir, t_vector *vct_home)
  70: 		ret_chdir = process_chdir(vct_home, vct_getstr(pwd),
  71: 				old_dir, vct_strdup(pwd));
  78: 	ret_chdir = process_chdir(vct_home, dir, NULL, NULL);
  84: 	t_vector	*vct_home;
  85: 	t_vector	*vct_old_pwd;
  88: 	vct_home = get_env_value_vct(get_env_list(GET), ENV_HOME);
  89: 	vct_old_pwd = get_env_value_vct(get_env_list(GET), ENV_OLD_PWD);
  90: 	if (process_error(vct_home, dir, vct_old_pwd) == CD_FAIL)
  92: 	ret_process_chdir = hub_process_chdir(dir, vct_home);

REPO • sources/builtins/cd/builtins_cd_check_bonus.c:
    3: int			process_error(t_vector *vct_home, char *dir, t_vector *vct_old_pwd)
    5: 	if (vct_home == NULL && dir == NULL)
   10: 	if (ft_strequ(STR_MINUS, dir) == TRUE && vct_getstr(vct_old_pwd) == NULL)
   15: 	if (vct_getlen(vct_old_pwd) == 0 && ft_strequ(dir, STR_MINUS) == TRUE)
   20: 	if (dir == NULL && vct_getlen(vct_home) == 0)
  102: 	new_dir = vct_new();
  104: 	if (vct_getlen(new_dir) == 0)
  107: 		dir = ft_strdup(vct_getstr(new_dir));
  108: 	vct_del(&new_dir);

REPO • sources/builtins/cd/builtins_cd_transform_bonus.c:
  42: 		vct_cutfrom(new_dir, 3);
  45: 	if (vct_getcharat(new_dir, vct_getlen(new_dir) - 1) == C_ROOT)
  46: 		vct_cut(new_dir);
  57: 		last_root = find_last_root(vct_getstr(new_dir));
  58: 		vct_cutfrom(new_dir, vct_getlen(new_dir) - last_root);
  66: 	t_vector	*vct_denied;
  67: 	t_vector	*real_vct_denied;
  69: 	vct_denied = vct_new();
  70: 	real_vct_denied = vct_new();
  71: 	vct_addstr(vct_denied, dir_denied);
  72: 	while (vct_getlen(vct_denied) > 0)
  74: 		while (vct_getfirstchar(vct_denied) == C_ROOT &&
  75: 				vct_getcharat(vct_denied, 1) == C_ROOT)
  76: 			vct_pop(vct_denied);
  77: 		vct_add(real_vct_denied, vct_getfirstchar(vct_denied));
  78: 		vct_pop(vct_denied);
  80: 	vct_addstr(new_dir, pwd);
  81: 	vct_add(new_dir, C_ROOT);
  82: 	vct_addstr(new_dir, vct_getstr(real_vct_denied));
  83: 	vct_del(&real_vct_denied);
  84: 	vct_del(&vct_denied);
  85: 	count_root = find_last_root_dot(vct_getstr(new_dir));

REPO • sources/builtins/exit/builtins_exit_bonus.c:
   3: void	handle_exit_value(t_vector *vct_av, t_vector *vct_av_cpy, char c)
   7: 	vct_cpy(vct_av, vct_av_cpy);
   9: 		vct_addcharat(vct_av, 0, c);
  10: 	exit_value = ft_atoi(vct_getstr(vct_av));
  11: 	vct_del(&vct_av);
  17: int		print_error(t_vector *vct_av, char *av, char c, int flag)
  20: 	if (vct_getlen(vct_av) == 0 && (flag == (NUM | MINUS_PLUS)))
  22: 	else if (flag == NUM || (vct_getlen(vct_av) != 0 &&
  30: 	vct_del(&vct_av);
  34: bool	parse_vct(t_vector *vct_av)
  40: 	av = vct_new();
  41: 	vct_cpy(av, vct_av);
  43: 	vct_cpy(vct_av, av);
  44: 	len_before = vct_getlen(vct_av);
  46: 	cut_arg(vct_av, len_before, count_num, av);
  47: 	while (vct_getlen(av) > 0)
  49: 		if (vct_getfirstchar(av) != C_SPACE && vct_getfirstchar(av) != C_TAB)
  51: 			vct_del(&av);
  54: 		vct_pop(av);
  56: 	vct_del(&av);
  62: 	t_vector	*vct_av;
  72: 	vct_av = vct_new();
  73: 	vct_addstr(vct_av, av[1]);
  74: 	pop_arg(vct_av, POP_SPACE_TAB);
  75: 	c = vct_getfirstchar(vct_av);
  77: 		vct_pop(vct_av);
  78: 	ret = check_arg(vct_av, c, av[1], ac);
  85: 		vct_del(&vct_av);
  88: 	vct_del(&vct_av);

REPO • sources/builtins/exit/builtins_exit_error_bonus.c:
   3: void	exit_error(t_vector *vct_av, char *av, char c, int flag)
   7: 						print_error(vct_av, av, c, MINUS_PLUS | NUM),
  10: 		ms_setenv_int(get_env_list(GET), "?", print_error(vct_av, av, c, NUM),
  13: 		ms_setenv_int(get_env_list(GET), "?", print_error(vct_av, av, c, NUM),

REPO • sources/builtins/exit/builtins_exit_utils_bonus.c:
    7: 	while (vct_getlen(av) > 0)
    9: 		c = vct_getfirstchar(av);
   12: 		vct_pop(av);
   17: void		cut_arg(t_vector *vct_av, size_t len_before, size_t count_num,
   24: 	vct_cutfrom(vct_av, len_before - count_num);
   25: 	len = vct_getlen(av);
   26: 	index_space = vct_clen(av, C_SPACE);
   27: 	index_tab = vct_clen(av, C_TAB);
   29: 		vct_cutfrom(av, len - (len - index_space));
   31: 		vct_cutfrom(av, len - (len - index_tab));
   41: 		while (vct_getlen(av) > 0 && (vct_getfirstchar(av) == C_SPACE ||
   42: 				vct_getfirstchar(av) == C_TAB))
   43: 			vct_pop(av);
   47: 		while (vct_getlen(av) > 0 && ft_isdigit(vct_getfirstchar(av)) == true)
   49: 			vct_pop(av);
   66: 	if (vct_getlen(av) > 19 && vct_getfirstchar(av) != '0')
   68: 	else if (vct_getlen(av) < 19)
   71: 	while (vct_getlen(av) > 0 && str[i] != '\0')
   73: 		first_c = vct_getfirstchar(av);
   81: 		vct_pop(av);
   86: int			check_arg(t_vector *vct_av, char c, char *av, int ac)
   88: 	t_vector	*vct_av_cpy;
   93: 	vct_av_cpy = vct_new();
   94: 	vct_cpy(vct_av_cpy, vct_av);
   95: 	num_arg = is_numeric(vct_av_cpy);
   96: 	if (num_arg == false || vct_getlen(vct_av) == 0)
   97: 		exit_error(vct_av, av, c, NUMFALSE_LENZERO);
   98: 	ret_parser = parse_vct(vct_av);
  100: 		exit_error(vct_av, av, c, PARSER_FALSE);
  101: 	vct_cpy(vct_av_cpy, vct_av);
  102: 	ret_long = is_long(vct_av, c);
  104: 		exit_error(vct_av, av, c, RETLONG_TRUE);
  107: 		vct_del(&vct_av_cpy);
  108: 		return (print_error(vct_av, NULL, c, ARG));
  110: 	handle_exit_value(vct_av, vct_av_cpy, c);

REPO • sources/cleaner/cleaner_bonus.c:
  54: 	input = vct_new();
  55: 	output = vct_new();
  57: 	vct_addstr(input, arg);
  63: 		vct_del(&input);
  64: 		vct_del(&output);
  74: 		transform_arg = vct_strdup(output);
  75: 	vct_del(&input);
  76: 	vct_del(&output);

REPO • sources/cleaner/cleaner_command/get_type_command_bonus.c:
   3: static bool	verif_expect(t_vector *vct, t_vector *vct_cpy)
   7: 	id_equal = vct_clen(vct, ASSIGN);
   8: 	vct_cutfrom(vct, vct_getlen(vct) - id_equal);
   9: 	if (ft_isdigit(vct_getfirstchar(vct)) == true ||
  10: 			vct_chr(vct, C_PATH) != FAILURE || is_wrong_ass(vct) == false)
  12: 		vct_del(&vct);
  13: 		vct_del(&vct_cpy);
  23: 	t_vector	*vct_cpy;
  25: 	vct = vct_new();
  26: 	vct_cpy = vct_new();
  27: 	vct_addstr(vct, str);
  28: 	vct_addstr(vct_cpy, vct_getstr(vct));
  29: 	nb_assign = vct_nbchar(vct_cpy, S_ASSIGN);
  32: 		vct_del(&vct);
  33: 		vct_del(&vct_cpy);
  36: 	if (verif_expect(vct, vct_cpy) == true)
  38: 	vct_del(&vct);
  39: 	vct_del(&vct_cpy);
  47: 	vct = vct_new();
  48: 	vct_addstr(vct, str);
  49: 	if (vct_getfirstchar(vct) == C_EXPORT)
  50: 		vct_pop(vct);
  53: 		vct_del(&vct);
  56: 	vct_del(&vct);

REPO • sources/cleaner/cleaner_command/verif_bonus.c:
   5: 	t_vector	*vct_cpy;
   7: 	vct_cpy = vct_new();
   8: 	vct_addstr(vct_cpy, vct_getstr(vct));
   9: 	if (vct_getfirstchar(vct_cpy) == LOW_LINE)
  10: 		vct_pop(vct_cpy);
  11: 	if (vct_getcharat(vct_cpy, vct_getlen(vct_cpy) - 1) == C_PLUS)
  12: 		vct_cut(vct_cpy);
  13: 	while (vct_getlen(vct_cpy) > 0)
  15: 		if (ft_isalnum(vct_getfirstchar(vct_cpy)) == false &&
  16: 				vct_getfirstchar(vct_cpy) != LOW_LINE)
  18: 			vct_del(&vct_cpy);
  21: 		vct_pop(vct_cpy);
  23: 	vct_del(&vct_cpy);
  27: size_t	verif_assign(t_vector *vct_av, size_t id_equal)
  31: 	vct = vct_new();
  32: 	vct_cpy(vct, vct_av);
  33: 	vct_cutfrom(vct, vct_getlen(vct) - id_equal);
  34: 	if (vct_getlen(vct) == 0)
  36: 		vct_del(&vct);
  39: 	if (ft_isdigit(vct_getfirstchar(vct)) == TRUE)
  41: 		vct_del(&vct);
  44: 	if (ft_isalnum(vct_getfirstchar(vct)) == false &&
  45: 			vct_getfirstchar(vct) != LOW_LINE)
  47: 		vct_del(&vct);
  50: 	vct_del(&vct);

REPO • sources/cleaner/cleaner_quote/cleaner_quote_bonus.c:
    7: 	while (vct_getlen(input) > 0)
    9: 		c = vct_getfirstchar(input);
   12: 		vct_add(output, c);
   13: 		vct_pop(input);
   24: 	expansion = vct_new();
   25: 	vct_pop(input);
   27: 	while (vct_getlen(input) > 0)
   29: 		c = vct_getfirstchar(input);
   32: 		vct_add(expansion, c);
   33: 		vct_pop(input);
   36: 	if (vct_getlen(expansion) == 0)
   37: 		vct_add(output, C_EXPORT);
   40: 		expansion_value = exp_value(vct_getstr(expansion));
   41: 		vct_addstr(output, expansion_value);
   43: 	vct_del(&expansion);
   50: 	vct_pop(input);
   51: 	while (vct_getlen(input) > 0)
   53: 		c = vct_getfirstchar(input);
   56: 		vct_add(output, c);
   57: 		vct_pop(input);
   59: 	vct_pop(input);
   69: 	vct_pop(input);
   72: 	while (vct_getlen(input) > 0)
   74: 		c = vct_getfirstchar(input);
   75: 		next_c = vct_getcharat(input, 1);
   78: 			vct_pop(input);
   79: 			vct_add(output, vct_getfirstchar(input));
   80: 			vct_pop(input);
   81: 			index = vct_clen(input, C_EXP);
   82: 			if (index == 0 && vct_getfirstchar(input) == C_EXP)
   84: 				vct_add(output, C_EXP);
   85: 				vct_pop(input);
   90: 				vct_add(output, vct_getfirstchar(input));
   91: 				vct_pop(input);
   99: 			vct_pop(input);
  100: 			vct_add(output, next_c);
  112: 		vct_add(output, c);
  113: 		vct_pop(input);
  115: 	if (vct_getfirstchar(input) == C_EXPORT && index == 2)
  119: 		index = vct_clen(output, C_QUOTE);
  120: 		while (index < vct_getlen(output))
  122: 			if (vct_getcharat(output, index) != C_QUOTE)
  124: 			if (vct_getcharat(output, index) == C_QUOTE)
  125: 				vct_popcharat(output, index);
  128: 	vct_pop(input);
  155: 		if (c == C_EXPORT && vct_getlen(input) != 1 &&
  156: 				(vct_getcharat(input, 1) == C_SIMPLE_QUOTE ||
  157: 				vct_getcharat(input, 1) == C_QUOTE))
  159: 			vct_pop(input);
  162: 		if (c == C_EXPORT && vct_getlen(input) != 1 &&
  163: 				is_exp_sep(vct_getcharat(input, 1)) == true &&
  164: 				vct_getcharat(input, 1) != QUESTION_MARK)
  167: 			vct_add(output, c);
  168: 		//	ft_printf("output 1 = %s\n", vct_getstr(output));//DEBUG
  169: 			vct_pop(input);
  170: 		//	ft_printf("input 1 = %s\n", vct_getstr(input));//DEBUG
  172: 		//	ft_printf("input after = %s\n", vct_getstr(input));
  173: 		//	ft_printf("output after = %s\n", vct_getstr(output));
  177: 		if (vct_getfirstchar(output) == C_EXP && vct_getlen(input) != 0
  178: 				&& vct_getfirstchar(input) != C_BACKSLASH)
  179: 			vct_pop(output);
  184: 		vct_add(output, c);
  185: 		vct_pop(input);
  196: 	while (vct_getlen(input) > 0)
  198: 		c = vct_getfirstchar(input);
  203: 	if (flag == 8 && vct_getlen(output) == 0)
  205: 	if ((flag & F_SQUOTE || flag & F_DQUOTE) && vct_getlen(output) == 0)
  207: 		vct_clear(output);
  208: 		vct_add(output, '\0');

REPO • sources/cleaner/cleaner_quote/cleaner_quote_utils_bonus.c:
   8: 	return (vct_getstr(vct));
  18: 	vct_pop(input);
  19: 	c = vct_getfirstchar(input);
  31: 	vct_pop(input);
  38: 	vct_add(output, vct_getfirstchar(input));
  39: 	vct_pop(input);

REPO • sources/env/get_env_bonus.c:
  53: 	if (value_vct != NOT_FOUND && (value_str = vct_getstr(value_vct)) != NULL)

REPO • sources/env/get_envp_bonus.c:
  11: 	str = vct_getstr(vct);
  29: 	env_value_len = vct_getlen(env_value);
  34: 	env_value_str = vct_getstr(env_value);

REPO • sources/env/init_env_bonus.c:
  17: 	if (vct_getstr(get_env_value_vct(env_lst, "PATH")) == NOT_FOUND)
  19: 	if (vct_getstr(get_env_value_vct(env_lst, "TERM")) == NOT_FOUND)

REPO • sources/env/print_env_bonus.c:
  8: 	env_value_str = vct_getstr(env_value);

REPO • sources/env/print_export_output_bonus.c:
  17: 		ft_putstr_fd(vct_getstr(env_value), STDOUT_FILENO);
  29: 	i = vct_getlen(env_value);
  32: 		char_at_index = vct_getcharat(tmp_env_value, i);
  34: 			safe_vct_addcharat(tmp_env_value, i, '\\');
  45: 	if (vct_chr(env_value, '\"') == FAILURE)
  49: 		tmp_env_value = vct_dup(env_value);
  54: 		vct_del(&tmp_env_value);

REPO • sources/env/store_env_bonus.c:
  16: 		new_env->env_value = vct_new();
  19: 		if (vct_addstr(new_env->env_value, (char *)env_value) == FAILURE)
  35: 			env_struct->env_value = vct_new();
  39: 			vct_clear(env_struct->env_value);
  40: 		if (vct_addstr(env_struct->env_value, (char *)new_env_value) == FAILURE)

REPO • sources/env/unset_env_bonus.c:
  12: 			vct_del(&env_value);

REPO • sources/error_manager/print_errno.c:
  16: 	tmp_err_src = vct_new();
  21: 		safe_vct_add(tmp_err_src, (char)error_source[0]);
  22: 		safe_vct_add(tmp_err_src, (char)error_source[1]);
  25: 		safe_vct_addstr(tmp_err_src, (char *)error_source);
  26: 	print_set_errno(EINVAL, error_str, function_name, vct_getstr(tmp_err_src));
  27: 	vct_del(&tmp_err_src);
  38: 	tmp_err_src = vct_new();
  41: 	safe_vct_add(tmp_err_src, '`');
  42: 	safe_vct_addstr(tmp_err_src, (char *)error_source);
  43: 	safe_vct_add(tmp_err_src, '\'');
  44: 	print_set_errno(EINVAL, error_str, function_name, vct_getstr(tmp_err_src));
  45: 	vct_del(&tmp_err_src);

REPO • sources/executor/locate_bin_bonus.c:
   9: 	path_env = vct_getstr(get_env_value_vct(get_env_list(GET), "PATH"));
  40: 	safe_vct_addstr(*vct, (char *)dir_option);
  41: 	safe_vct_addstr(*vct, "/");
  42: 	safe_vct_addstr(*vct, (char *)bin_name);
  54: 	full_path_vct = vct_new();
  58: 	ret = stat_path(vct_getstr(full_path_vct));
  61: 		full_path = vct_getstr(full_path_vct);
  65: 	vct_del(&full_path_vct);

REPO • sources/executor/signal_manager_bonus.c:
  38: 	if (le != NULL && le->prompt_len + le->vct_index != 0)
  40: 		le->cy = (le->prompt_len + le->vct_index - 1) / (le->scols);
  42: 			le->cx = (le->prompt_len + le->vct_index) - (le->scols / le->cy);

REPO • sources/exit_routines/exit_routine_bonus.c:
  38: 			vct_del(&data->cmd_line);

REPO • sources/exit_routines/exit_routine_line_editor_bonus.c:
   9: 		vct_del(&vct);
  39: 		// vct_del(&le->cmd_line);
  40: 		vct_del(&le->clipboard);

REPO • sources/lexer/free_list_bonus.c:
  23: 		vct_del(&word);
  25: 		vct_del(&vct);
  27: 		vct_del(&tmp);
  49: 	if (vct_getlen(word) != 0 && flag == TOKEN)

REPO • sources/lexer/handle_no_word_bonus.c:
   5: 	const char c = vct_getfirstchar(input);
   6: 	const char c_next = vct_getcharat(input, 1);
  15: 			vct_add(word, c);
  16: 			vct_pop(input);
  32: 	while (vct_getlen(input) > 0)
  34: 		c = vct_getfirstchar(input);
  48: 			else if (ret_parse == true && vct_getlen(input) != 1 && dquote_state == 1 && quote_state == 0)
  50: 			else if (ret_parse == true && vct_getlen(input) != 1 && dquote_state == 0 && quote_state == 1)
  52: 			else if (ret_parse == true && vct_getlen(input) == 1 && dquote_state != 1)
  59: 		c = vct_getfirstchar(input);
  60: 		vct_add(word, c);
  61: 		vct_pop(input);

REPO • sources/lexer/handle_no_word_utils_bonus.c:
   8: 	cpy_input = vct_new();
   9: 	vct_cpy(cpy_input, input);
  10: 	vct_cutfrom(cpy_input, vct_getlen(cpy_input) - 2);
  12: 	if (ft_strequ(vct_getstr(cpy_input), OR) == TRUE
  13: 			|| ft_strequ(vct_getstr(cpy_input), AND) == TRUE
  14: 			|| ft_strequ(vct_getstr(cpy_input), DOUBLE_GREATER) == TRUE)
  16: 	vct_del(&cpy_input);
  29: 	const char	c = vct_getfirstchar(input);
  36: 	const char	c = vct_getfirstchar(input);
  43: 	const char	c = vct_getfirstchar(input);

REPO • sources/lexer/lexer_bonus.c:
   9: 	vct_pop(input);
  11: 		vct_pop(input);
  24: 	if (vct_getlen(word) != 0)
  26: 		if (vct_chr(word, ASSIGN) > 0)
  28: 		else if (vct_getfirstchar(word) == EXP)
  30: 		ret = extract_token(token_list, vct_getstr(word), type);
  32: 	vct_clear(word);
  43: 	while (vct_getfirstchar(input) == C_SPACE
  44: 			|| vct_getfirstchar(input) == C_TAB)
  45: 		vct_pop(input);
  46: 	c = vct_getfirstchar(input);
  47: 	if (vct_getlen(input) == 0)
  67: 	word = vct_new();
  71: 	while (vct_getlen(input) > 0)
  80: 	vct_del(&word);

REPO • sources/lexer/lexer_utils_bonus.c:
  18: 	if (vct_getlen(word) != 0)

REPO • sources/lexer/quote_checker_bonus.c:
   7: 	else if (vct_getfirstchar(input) == '\0')
  16: 	else if (vct_getfirstchar(input) == '\0')
  35: 			vct_getfirstchar(input) == C_BACKSLASH)
  37: 		vct_pop(input);
  38: 		vct_pop(input);
  51: 	input = vct_new();
  53: 	vct_addstr(input, str);
  61: 		vct_pop(input);
  63: 	vct_del(&input);
  66: 		vct_del(&input);
  69: 	vct_del(&input);

REPO • sources/lexer/token_bonus.c:
  10: 	if (vct_chrnstr(input, DOUBLE_GREATER) == FALSE)
  12: 	else if (vct_chrnstr(input, OR) == FALSE)
  14: 	else if (vct_chrnstr(input, AND) == FALSE)
  80: 	if (vct_chr(vct, EXP) != FAILURE && vct_chr(vct, ASSIGN) == FAILURE)
  81: 		ret = extract_token(token_list, vct_getstr(vct), E_EXP);
  82: 	else if (vct_chr(vct, ASSIGN) != FAILURE && vct_chr(vct, ASSIGN) != 0)
  83: 		ret = extract_token(token_list, vct_getstr(vct), E_ASSIGN);
  85: 		ret = extract_token(token_list, vct_getstr(vct), E_WORD);
  86: 	vct_clear(vct);

REPO • sources/line_editor/line_editor_bonus.c:
  12: 		le->vct_index_backup = le->vct_index;
  13: 		if (key == K_EOF && vct_getlen(le->cmd_line) == 0)

REPO • sources/line_editor/debug/debug_tools.c:
  23: 	ft_printf("line [%d] vct_index [%d] ", le->cy, le->vct_index);
  24: 	ft_printf("vct_len[%d] char_in_vct [%c]", vct_getlen(le->cmd_line),
  25: 	vct_getcharat(le->cmd_line, le->vct_index));
  27: 	ft_printf("select_min/max [%d/%d] vct_content : \n___%s\n", le->select_min,
  28: 		le->select_max, vct_getstr(le->cmd_line));
  31: 	ft_printf("Clipboard [%s]", vct_getstr(le->clipboard));

REPO • sources/line_editor/display/print_command_line_bonus.c:
  27: 	int			vct_len;
  32: 	v_str = vct_getstr(le->cmd_line);
  33: 	vct_len = vct_getlen(le->cmd_line);
  39: 		safe_write(fd, v_str + le->select_max + 1, vct_len - le->select_max);
  48: 		safe_write(fd, v_str + le->select_max + 1, vct_len - le->select_max);
  60: 	index_from = le->vct_index;
  61: 	delta = vct_getlen(le->cmd_line) - index_from;
  63: 		safe_write(STDOUT_FILENO, vct_getstr(le->cmd_line) + index_from, delta);

REPO • sources/line_editor/display/refresh_command_line_bonus.c:
  13: 	while (le->vct_index > head_of_block)
  30: 	if (le->vct_index == 0)
  32: 	if (le->vct_index == (int)vct_getlen(le->cmd_line)
  34: 		head_of_block = le->vct_index - 1;
  40: static void	move_cursor_at_backup(t_le *le, int index_backup, int vct_len)
  42: 	if (index_backup != UNSET && index_backup < (vct_len - le->vct_index) / 2)
  44: 		while (le->vct_index > index_backup)
  46: 		while (le->vct_index <= index_backup)
  50: 		while (le->vct_index > index_backup)
  57: 	int		vct_len;
  63: 		vct_len = vct_getlen(le->cmd_line);
  64: 		index_backup = (le->vct_index < vct_len) ? le->vct_index : UNSET;
  68: 		move_cursor_at_index(vct_len);
  70: 			move_cursor_at_backup(le, index_backup, vct_len);

REPO • sources/line_editor/handlers/handle_print_char_bonus.c:
   9: 		safe_vct_addcharat(le->cmd_line, le->vct_index, c);
  22: 		le->vct_index++;

REPO • sources/line_editor/handlers/clipboard/copy_bonus.c:
  13: 		vct_clear(le->clipboard);
  14: 		if (le->vct_index > (int)vct_getlen(le->cmd_line))
  16: 		copy_start = (le->select_min == -1) ? le->vct_index : le->select_min;
  17: 		copy_end = (le->select_max == -1) ? le->vct_index : le->select_max;
  21: 			safe_vct_add(le->clipboard, vct_getcharat(le->cmd_line, i));

REPO • sources/line_editor/handlers/clipboard/paste_bonus.c:
   5: 	return (index == 0 || index == vct_getlen(cmd_line));
  19: 		clipboard_len = vct_getlen(le->clipboard);
  25: 			clipboard_content = vct_getcharat(le->clipboard, i);
  30: 		if (is_at_start_or_end_of_line(le->vct_index, le->cmd_line) == false)

REPO • sources/line_editor/handlers/selection/selection_bonus.c:
   8: 	le->select_min = (le->vct_index < le->vct_index_backup) ?
   9: 										le->vct_index : le->vct_index_backup;
  10: 	le->select_max = (le->vct_index < le->vct_index_backup) ?
  11: 										le->vct_index_backup : le->vct_index;
  16: 	int		vct_len;
  22: 	vct_len = (int)vct_getlen(le->cmd_line);
  23: 	if (le->vct_index_backup == le->vct_index)
  27: 	else if (le->vct_index < le->select_min && le->vct_index < le->select_max)
  28: 		le->select_min = le->vct_index;
  29: 	else if (le->vct_index > le->select_min && le->vct_index > le->select_max)
  30: 		le->select_max = le->vct_index;
  32: 		le->select_max = le->vct_index;
  34: 		le->select_min = le->vct_index;

REPO • sources/line_editor/handlers/special_keys/delete_bonus.c:
  11: 		if (key == K_DEL_BACKWARD && le->vct_index == 0)
  15: 		vct_popcharat(le->cmd_line, le->vct_index);
  21: 			vct_popcharat(le->cmd_line, i--);

REPO • sources/line_editor/handlers/special_keys/history_bonus.c:
  35: 		le->cmd_line_backup = vct_strdup(le->cmd_line);
  43: 	t_vector		*vct_history_element;
  51: 		vct_history_element = browse_history(key);
  52: 		if (vct_history_element != NULL)
  53: 			safe_vct_cpy(le->cmd_line, vct_history_element);
  56: 			vct_clear(le->cmd_line);
  57: 			if (vct_pushstr(le->cmd_line, le->cmd_line_backup) == FAILURE)
  73: 	if (le != NULL && le->cmd_line != NULL && vct_getlen(le->cmd_line) > 0)
  75: 		new_history_element = ft_lstnew(vct_dup(le->cmd_line));

REPO • sources/line_editor/handlers/special_keys/move_bonus.c:
  25: 	int		vct_len;
  29: 	vct_len = (int)vct_getlen(le->cmd_line);
  30: 	while (le->vct_index < vct_len)
  32: 		if (vct_getcharat(le->cmd_line, le->vct_index) != ' ')
  36: 	while (le->vct_index < vct_len)
  38: 		if (vct_getcharat(le->cmd_line, le->vct_index) == ' ')
  49: 	while (le->vct_index > 0)
  51: 		if (vct_getcharat(le->cmd_line, le->vct_index - 1) != ' ')
  55: 	while (le->vct_index > 0)
  57: 		if (vct_getcharat(le->cmd_line, le->vct_index - 1) == ' ')

REPO • sources/line_editor/init/init_line_editor_bonus.c:
   8: 	term_name = vct_getstr(get_env_value_vct(get_env_list(GET), "TERM"));
  55: 	le->clipboard = vct_new();

REPO • sources/line_editor/init/init_prompt_bonus.c:
  25: 		vct_clear(data->cmd_line);
  41: 		le->vct_index = 0;

REPO • sources/line_editor/utils/exit_routine_le_bonus.c:
   9: 		vct_del(&vct);
  44: 		vct_del(&le->cmd_line);
  45: 		vct_del(&le->clipboard);

REPO • sources/line_editor/utils/utils_cursor_bonus.c:
   28: 	if (le->vct_index <= 0)
   42: 	le->vct_index--;
   51: 	if (le->vct_index >= (int)vct_getlen(le->cmd_line))
   65: 	le->vct_index++;
   77: 	index_delta = index_to - le->vct_index;
   82: 	le->vct_index = index_to;
   91: 	if (le->vct_index == 0)
  102: 		le->vct_index = 0;
  104: 		le->vct_index = (le->scols * (le->cy - 1)) + le->scols - le->prompt_len;
